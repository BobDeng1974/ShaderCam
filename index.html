<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Shader Camera by yulu</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Shader Camera</h1>
        <h2>Demo app to discuss rendering camera frame using OpenGL ES</h2>
        <a href="https://github.com/yulu/ShaderCam" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h2>
<a id="shader-camera" class="anchor" href="#shader-camera" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shader Camera</h2>

<p>By <a href="http://littlecheesecake.me">LittleCheeseCake</a></p>

<p>Occasionally I receives emails asking how to render Camera Frame using OpenGL ES on Android. I lazily used some codes from an open source project <a href="https://github.com/harism/android_instacam">InstaCam</a> without fully understand until recently I reviewed some fundamentals of OpenGL ES and re-impelemented a demo app for camera frame rendering using shaders. This post is to discuss some key aspects in the implementation and share the demo codes.</p>

<h3>
<a id="camerarenderer" class="anchor" href="#camerarenderer" aria-hidden="true"><span class="octicon octicon-link"></span></a>CameraRenderer</h3>

<p>Drawing using OpenGL is implemented by rendering on GLSurfaceView. The common approach is subclass the GLSurfaceView and implements the GLSurfaceView.Renderer. The rendering tasks are performed by implementing the interface.</p>

<div class="highlight highlight-java"><pre><span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">CameraRenderer</span> <span class="pl-s">extends</span> <span class="pl-e">GLSurfaceView</span> <span class="pl-s">implements</span> 
                                <span class="pl-e">GLSurfaceView</span>.<span class="pl-e">Renderer</span>, 
                                <span class="pl-e">SurfaceTexture</span>.<span class="pl-e">OnFrameAvailableListener</span>{
    <span class="pl-st">@Override</span>
    <span class="pl-s">public</span> <span class="pl-s">synchronized</span> <span class="pl-st">void</span> <span class="pl-en">onSurfaceCreated</span>(<span class="pl-stj">GL10</span> <span class="pl-v">gl</span>, <span class="pl-stj">EGLConfig</span> <span class="pl-v">config</span>)
    {
        <span class="pl-c1">...</span>
        <span class="pl-c">//compile shader here</span>
    }

    <span class="pl-st">@Override</span>
    <span class="pl-s">public</span> <span class="pl-s">synchronized</span> <span class="pl-st">void</span> <span class="pl-en">onSurfaceChanged</span>(<span class="pl-stj">GL10</span> <span class="pl-v">gl</span>, <span class="pl-st">int</span> <span class="pl-v">width</span>, <span class="pl-st">int</span> <span class="pl-v">height</span>) {
       <span class="pl-c1">...</span>
       <span class="pl-c">//open camera and start preview here</span>
    }

    <span class="pl-st">@Override</span>
    <span class="pl-s">public</span> <span class="pl-s">synchronized</span> <span class="pl-st">void</span> <span class="pl-en">onDrawFrame</span>(<span class="pl-stj">GL10</span> <span class="pl-v">gl</span>) {
        <span class="pl-c1">...</span>
        <span class="pl-c">//draw frame as required</span>
    }

}</pre></div>

<h3>
<a id="surfacetexture" class="anchor" href="#surfacetexture" aria-hidden="true"><span class="octicon octicon-link"></span></a>SurfaceTexture</h3>

<p>SurfaceTexture Interface provided by Android SDK (API Level 11+) has made our life much easier when dealing with image streaming either from Camera or MediaPlayer. SurfaceTexture is bound with an OpenGL Texture id at its instantiate (mCameraTexture is discussed later, which generates OpenGL texture handle):</p>

<div class="highlight highlight-java"><pre>@<span class="pl-stj">Override</span>
<span class="pl-s">public</span> <span class="pl-s">synchronized</span> <span class="pl-st">void</span> onSurfaceChanged(<span class="pl-c1">GL10</span> gl, <span class="pl-st">int</span> width, <span class="pl-st">int</span> height) {
    <span class="pl-c1">...</span>
    <span class="pl-stj">SurfaceTexture</span> mSurfaceTexture <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">SurfaceTexture</span>(mCameraTexture<span class="pl-k">.</span>getTextureId());
    <span class="pl-c1">...</span>
}
</pre></div>

<p>Listeners can be registered to SurfaceTexture.setOnFrameAvailable to make updates whenever a new frame is streamed in. Here the camera renderer is registered to listening for the updates, whenever a new frame is streamed in, the renderer is required to draw a new frame on the surface. Use mSurfaceTexture.updateTexImage() to query the most recent frame on the stream.</p>

<div class="highlight highlight-java"><pre>@<span class="pl-stj">Override</span>
<span class="pl-s">public</span> <span class="pl-s">synchronized</span> <span class="pl-st">void</span> onSurfaceChanged(<span class="pl-c1">GL10</span> gl, <span class="pl-st">int</span> width, <span class="pl-st">int</span> height) {
    <span class="pl-c1">...</span>
    mSurfaceTexture<span class="pl-k">.</span>setOnFrameAvailableListener(<span class="pl-v">this</span>);
    <span class="pl-c1">...</span>
}

<span class="pl-c1">...</span>

@<span class="pl-stj">Override</span>
<span class="pl-s">public</span> <span class="pl-s">synchronized</span> <span class="pl-st">void</span> onFrameAvailable(<span class="pl-stj">SurfaceTexture</span> surfaceTexture)
{
    <span class="pl-c">//request the renderer to draw frame when new frame available</span>
    updateTexture <span class="pl-k">=</span> <span class="pl-c1">true</span>;
    requestRender();
}

<span class="pl-c1">...</span>

@<span class="pl-stj">Override</span>
<span class="pl-s">public</span> <span class="pl-s">synchronized</span> <span class="pl-st">void</span> onDrawFrame(<span class="pl-c1">GL10</span> gl) {
    <span class="pl-c1">...</span>
    <span class="pl-c">//render the texture to FBO if new frame is available, double check</span>
    <span class="pl-k">if</span>(updateTexture){
        mSurfaceTexture<span class="pl-k">.</span>updateTexImage();
        <span class="pl-c1">...</span>
    }
}</pre></div>

<p>The texture updated by SurfaceTexture can only be bound to GL_TEXTURE_EXTERNAL_OES target rather than the GL_TEXTURE_2D target. Therefore a texture handle generated by the mCameraTexture object as mentioned above using the following implementation (bind with GLES11Ext.GL_TEXTURE_EXTERNAL_OES):</p>

<div class="highlight highlight-java"><pre><span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">OESTexture</span> {
    <span class="pl-c1">...</span>

    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">init</span>(){
        <span class="pl-st">int</span>[] mTextureHandles <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">int</span>[<span class="pl-c1">1</span>];
        <span class="pl-c1">GLES20</span><span class="pl-k">.</span>glGenTextures(<span class="pl-c1">1</span>, mTextureHandles, <span class="pl-c1">0</span>);
        mTextureHandle <span class="pl-k">=</span> mTextureHandles[<span class="pl-c1">0</span>];

        <span class="pl-c1">GLES20</span><span class="pl-k">.</span>glBindTexture(<span class="pl-stj">GLES11Ext</span><span class="pl-c1"><span class="pl-k">.</span>GL_TEXTURE_EXTERNAL_OES</span>, mTextureHandles[<span class="pl-c1">0</span>]);
        <span class="pl-c1">...</span>

    }
}</pre></div>

<p>In the fragment shader when the texture is binded, the first line has to be inserted:</p>

<div class="highlight highlight-c"><pre>#extension GL_OES_EGL_image_external : require

precision mediump <span class="pl-st">float</span>;

uniform samplerExternalOES <span class="pl-vo">sTexture</span>;
varying vec2 vTextureCoord;

<span class="pl-st">void</span> <span class="pl-en">main</span>(){
    gl_FragColor = <span class="pl-s3">texture2D</span>(<span class="pl-vo">sTexture</span>, vTextureCoord);
}</pre></div>

<h3>
<a id="draw-screen-quad" class="anchor" href="#draw-screen-quad" aria-hidden="true"><span class="octicon octicon-link"></span></a>Draw Screen Quad</h3>

<p>Using shaders, a simple screen quad can be easily drawn.</p>

<div class="highlight highlight-java"><pre><span class="pl-s">private</span> <span class="pl-st">void</span> init(){
    <span class="pl-c">//Create full scene quad buffer</span>
    <span class="pl-s">final</span> <span class="pl-st">byte</span> <span class="pl-c1">FULL_QUAD_COORDS</span>[] <span class="pl-k">=</span> {<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>};
    mFullQuadVertices <span class="pl-k">=</span> <span class="pl-stj">ByteBuffer</span><span class="pl-k">.</span>allocateDirect(<span class="pl-c1">4</span> <span class="pl-k">*</span> <span class="pl-c1">2</span>);
    mFullQuadVertices<span class="pl-k">.</span>put(<span class="pl-c1">FULL_QUAD_COORDS</span>)<span class="pl-k">.</span>position(<span class="pl-c1">0</span>);

    <span class="pl-c1">...</span>
}

<span class="pl-c1">...</span>
<span class="pl-s">private</span> <span class="pl-st">void</span> renderQuad(<span class="pl-st">int</span> aPosition){
    <span class="pl-c1">GLES20</span><span class="pl-k">.</span>glVertexAttribPointer(aPosition, <span class="pl-c1">2</span>, <span class="pl-c1">GLES20<span class="pl-k">.</span>GL_BYTE</span>, <span class="pl-c1">false</span>, <span class="pl-c1">0</span>, mFullQuadVertices);
    <span class="pl-c1">GLES20</span><span class="pl-k">.</span>glEnableVertexAttribArray(aPosition);
    <span class="pl-c1">GLES20</span><span class="pl-k">.</span>glDrawArrays(<span class="pl-c1">GLES20<span class="pl-k">.</span>GL_TRIANGLE_STRIP</span>, <span class="pl-c1">0</span>, <span class="pl-c1">4</span>);
}</pre></div>

<p>Three issues are considered here </p>

<ol>
<li><p>A transformation matrix is queried using mSurfaceTexture.getTransformMatrix(float[]). This matrix transforms traditional 2D OpenGL ES texture coordinate column vectors of the form (s, t, 0, 1) where s and t are on the inclusive interval [0, 1] to the proper sampling location in the streamed texture. </p></li>
<li><p>The orientation change of the phone has effect on the Surface dimension change (Height and Width swapped) but has no effect on the camera size (Width and Height remains as Width &gt; Height all the time). This should be considered using an orientation matrix passed to the shader to adjust the orientation of the frame whenever the phone's orientation changes.</p></li>
<li><p>The screen dimension (SurfaceView dimension and the camera frame dimension might not be the same, to maintain a proper w/h ratio, a scaling factor should be passed to the shader to resize the screen quad.</p></li>
</ol>

<p>The codes below are the passing of the three parameters to the shader. Noted that uTransformM updated every frame as required, uOrientationM updated whenever the orientation of the phone changes, and ratios updated also when the orientation of the phone changes since the w/h ratio changes when their actual values change. The later two are updated in the onSurfaceChanged(GL10, int width, int height) method. </p>

<div class="highlight highlight-java"><pre>@<span class="pl-stj">Override</span>
<span class="pl-s">public</span> <span class="pl-s">synchronized</span> <span class="pl-st">void</span> onDrawFrame(<span class="pl-c1">GL10</span> gl) {
    <span class="pl-c1">...</span>
    <span class="pl-st">int</span> uTransformM <span class="pl-k">=</span> mOffscreenShader<span class="pl-k">.</span>getHandle(<span class="pl-s1"><span class="pl-pds">"</span>uTransformM<span class="pl-pds">"</span></span>);
    <span class="pl-st">int</span> uOrientationM <span class="pl-k">=</span> mOffscreenShader<span class="pl-k">.</span>getHandle(<span class="pl-s1"><span class="pl-pds">"</span>uOrientationM<span class="pl-pds">"</span></span>);
    <span class="pl-st">int</span> uRatioV <span class="pl-k">=</span> mOffscreenShader<span class="pl-k">.</span>getHandle(<span class="pl-s1"><span class="pl-pds">"</span>ratios<span class="pl-pds">"</span></span>);

    <span class="pl-c1">GLES20</span><span class="pl-k">.</span>glUniformMatrix4fv(uTransformM, <span class="pl-c1">1</span>, <span class="pl-c1">false</span>, mTransformM, <span class="pl-c1">0</span>);
    <span class="pl-c1">GLES20</span><span class="pl-k">.</span>glUniformMatrix4fv(uOrientationM, <span class="pl-c1">1</span>, <span class="pl-c1">false</span>, mOrientationM, <span class="pl-c1">0</span>);
    <span class="pl-c1">GLES20</span><span class="pl-k">.</span>glUniform2fv(uRatioV, <span class="pl-c1">1</span>, mRatio, <span class="pl-c1">0</span>);
    <span class="pl-c1">...</span>
}</pre></div>

<p>In the vertex shader, uTransformM, uOrientationM and ratios together do some work to make sure the frame texture coordinate fit into the phone window:</p>

<div class="highlight highlight-c"><pre>uniform mat4 uTransformM;
uniform mat4 uOrientationM;
uniform vec2 ratios;
attribute vec2 aPosition;

varying vec2 vTextureCoord;

<span class="pl-st">void</span> <span class="pl-en">main</span>(){
    gl_Position = <span class="pl-s3">vec4</span>(aPosition, <span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>);
    vTextureCoord = (uTransformM * ((uOrientationM * gl_Position + <span class="pl-c1">1.0</span>)*<span class="pl-c1">0.5</span>)).<span class="pl-vo">xy</span>;
    gl_Position.<span class="pl-vo">xy</span> *= ratios;
}</pre></div>

<h3>
<a id="closure" class="anchor" href="#closure" aria-hidden="true"><span class="octicon octicon-link"></span></a>Closure</h3>

<p>Some details are not covered in the post. It might be confusing by looking at the code fragments above. Here what I want to do is to take note of the critical steps in my implementation for my own record. I think it will be much helpful to go through the complete implementation of the <a href="https://github.com/yulu/ShaderCam">demo app</a> (which is quite concise, only a few hundered lines of codes). What will be more interesting? Try to replace the fragment shader with some funny shaders in <a href="https://github.com/yulu/Instagram_Filter">Instagram_Filter</a> and <a href="https://github.com/yulu/ShaderFilter">ShaderFilter</a>, to see the interesting filter applied real-time on camera view.</p>

<p><img src="https://dl.dropboxusercontent.com/spa/pv9m61pztxstay5/manga.png" alt="manga"></p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/yulu/ShaderCam/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/yulu/ShaderCam/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/yulu/ShaderCam"></a> is maintained by <a href="https://github.com/yulu">yulu</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
